# Outline
- [Extensibility, Safety and Performance in the SPIN Operating System](https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/Note_papers.md#extensibility-safety-and-performance-in-the-spin-operating-system)
- Exokernel: An Operating System Architecture for Application-Level Resource Management
- On Micro-Kernel Construction
- Improved Address-Space Switching on Pentium Processors by Transparently Multiplexing User Address Spaces
- Xen and the Art of Virtualization
- Memory Resource Management in VMware ESX Server

<p align="center">
   <img src="https://user-images.githubusercontent.com/62491253/151467512-d346c262-fddb-4b67-a976-34cd822b7770.png" alt="drawing" width="500"/>
</p>

<h2>Extensibility, Safety and Performance in the SPIN Operating System</h2>
<p>Bershad, B. N., Savage, S., Pardyak, P., Sirer, E. G., Fiuczynski, M. E., Becker, D., Chambers, C., & Eggers, S. (1995). Extensibility safety and performance in the SPIN operating system. ACM SIGOPS Operating Systems Review, 29(5), 267–283. </p>


<ul>
   <li> <strong>SPIN is an operating system</strong> that can be dynamically specialized to safely meet the performance and functionality re-quirements of applications. </li>  
   
   <li> <strong>Goals and approach </strong>
      <ul>
         <li> Goals - extensibility, safety and good performance
            <ul>
               <li>Extensibility: determined by the interfaces to services and resources that are exported to applications</li>
               <li>Safety: the exposure of applications to the actions of others, and requires that access be controlled at the same granularity at which extensions are defined</li>
               <li>Good performance: low overhead communication between an extension and the system</li>
             </ul></li>
         <li>the SPIN operating system relies on four techniques implemented at the level of the language or its runtime
            <ul>
               <li>Co-location: Operating system extensions are dynamically linked into the kernel virtual address space. Co-location enables communication between system and extension code to have low cost</li>
               <li>Enforced modularity: Extension is written in Modula-3,a modular programming language for which the compiler enforces interface boundaries between modules. Extensions, which execute in the kernel’s virtual address space, cannot access memory or execute privileged instructions unless they have been given explicit access through an interface. Modularity enforced by the compiler enables modules to be isolated from one another with low cost</li>
               <li> Logical protection domains: Extensions exist within logical protection domains, which are kernel namespaces that contain code and exported interfaces. Interfaces, which are language-level units, represent views on system resources that are protected by the operating system. An in-kernel dynamic linker resolves code in separate logical protection domains at runtime, en-abling cross-domain communication to occur with the overhead of a procedure call</li>
               <li> Dynamic call binding: Extensions execute in response to system events. An event can describe any potential action in the system, such as a virtual memory page fault or the scheduling of a thread. Events are declared within interfaces, and can be dispatched with the overhead of a procedure call. </li>
            </ul>
         </li>         
      </ul>
   </li>
   
   <li>SPIN is primarily written in Modula-3, which allows extensions to directly use system interfaces without requiring runtime conversion when communicating with other system code. Although SPIN relies on language features to ensure safety withinthe kernel, applications can be written in any language and execute within their own virtual address space. Only code that requires low-latency access to system services is written in the system’s safe extension language. For example, we have used SPIN to implement a UNIX operating system server. The bulk of the server is written in C, and executes within its own address space (as do applications). The server consists of a large body of code that implements the DEC OSF/1 system call interface, and a small number of SPINextensions that provide the thread, virtual memory, and device interfaces required by the server. </li>
   <li> Motiviation: An extensible system is one that can be changed dynamically to meet the needs of an application.</li>
   
   <li> <strong>The SPIN Architecture </strong>
      <ul>
      <li> SPIN makes few demands of the hardware, and instead relies on language-level services, such as static typechecking and dynamic linking</li>
      <li>Modula-3's key features of the language include support for inter-faces, type safety, automatic storage management, objects, generic interfaces, threads, and exceptions. The design of SPIN depends only on the language’s safety and encapsulation mechanisms,specifically interfaces. </li>
      <li>Capabilities: All kernel resources in SPIN are referenced by capabilities. A capability is an unforgeable reference to a resource which can be a system object, an interface, or a collection of interfaces. SPIN implements capabilities directly using pointers, which are supported by the language.A pointer is a reference to a block of memory whose type is declared within an interface. Sample code is provided in section 3.1 The protection model Capabilities</li>
      <li>In SPIN the naming and protection interface is at the level of the language, not of the virtual memory system. A domain, named by a capability, is used to control dynamic linking, and corresponds to one or more safe object files with one or more exported interfaces. An object file is safe if it is unknown to the kernel but has been signed by the Modula-3 compiler, or if the kernel can otherwise as-sert the object file to be safe. Protection domains: Create, Resolve, Combine. Sample code is provided in section Protection domains </li>
      <li>Extensions in SPIN are defined in terms of events and handlers.An event is a message that announces a change in the state of the system or a request for service. An event handler is a procedure that receives the message. An extension installs a handler on an event by explicitly registering the handler with the event through a central dispatcher that routes events to handlers. Event names are protected by the domain machinery. An event is defined as a procedure exported from an interface and its handlers are defined as procedures having the same type. A handler is invoked with the arguments specified by the event raise.The right to call a procedure is equivalent to the right to raise the event named by the procedure.</li>
      </ul>
   </li>
   <li> <strong>The core services</strong>
      <ul>
      <li>Extensible memory management:  The SPIN memory management interface decomposes memory services into three basic components: physical storage, naming, and translation.These correspond to the basic memory resources exported by processors, namely physical addresses, virtual addresses, and translations. Application-specific services interact with these three services to define higher level virtual memory abstractions, such as address spaces. </li>
      <li>Extensible thread management:  An operating system’s thread management system provides applications with interfaces for scheduling, concurrency, and synchronization. Applications, though, can require levels of functionality and performance that a thread management system is unable to deliver.In SPIN an application can provide its own thread package and scheduler that executes within the kernel.The thread package defines the application’s execution model and synchronization constructs. Although SPIN does not define a thread model for applications, it does define the structure on which an implementation of a thread model rests. This structure is defined by a set of events that are raised or handled by schedulers and thread packages. A scheduler multiplexes the underlying processing resources among competing contexts, called strands. A strand is similar to a thread in traditional operating systems in that it reflects some processor context. Unlike a thread though, a strand has no minimal or requisite kernel state other than a name. An application-specific thread package defines an implementation of the strand interface for its own threads.Together, the thread package and the scheduler implement the control flow mechanisms for user-space contexts.Application-specific thread packages only manipulate the flow of control for application threads executing outside of the kernel. For safety reasons, the responsibility for scheduling and synchronization within the kernel belongs to the kernel. As a thread transfers from user mode to kernel mode, it is checkpointed and a Modula-3 thread executes in the kernel on its behalf. As the Modula-3 thread leaves the kernel, the blocked application-specific thread is resumed. A global scheduler implements the primary processor allocation policy between strands.Additional application-specific schedulers can be placed on top of the global scheduler.That is, an application-specific scheduler presents itself to the global scheduler as a thread package. </li>
      <li>Implications for trusted services: The core services are trusted, which means that they must perform according to their interface specification. In designing the interfaces for SPIN’s trusted services, we have worked to ensure that an extension’s failure to use an interface correctly is isolated to the extension itself</li>
      <li>Code check paper Figure 3 & Figure 4 for memory VPN,PPN & translation and threads strand</li>
      </ul>
   </li>
   
  <li> <strong>System performance </strong>
      <ul>
      <li>Evaluate the performance of SPIN from System size (codebase), Microbenchmarks (Measurements of low-level system services, such as protected communication, thread management and virtual memory to reveal the overhead of basic system functions), Networking, End-to-end performance (application) </li>
      <li> Compared monolithic (DEC OSF/1 V2.1), MicroKernel (Mach) and SPIN </li>
      <li> Protected communication: 1) protected in-kernel call in SPIN is implemented as a procedure call between two domains that have been dynamically linked. SPIN>rest(NA) 2) System call overhead reflects the time to cross the user-kernel boundary, execute a procedure and return. MACH > DEC > SPIN  3) Cross-address space call shows the time to perform a protected, cross-address space procedure call. DEC OSF/1 supports cross-address space procedure call using sockets and SUN RPC. Mach provides an optimized path for cross-address space communication using messages. SPIN’s cross-address space procedure call is implemented as an extension that uses system calls to transfer control in and out of the kernel and cross-domain procedure calls within the kernel to transfer control between address spaces. DEC > MACH > SPIN </li>
      <li>Thread management: 1) Measurement on "the time to create, schedule, and terminate a new thread, synchronizing the termination with another thread." 2) Measurement on "synchronization overhead, and measures the time for a pair of threads to synchronize with one another" 3) Conclusion - SPIN’s extensible thread implementation does not incur a perfor-mance penalty when compared to non-extensible ones, even when integrated with kernel services.</li>
      <li>Virtual memory:1) measure the time for an application to query the status of a particular virtual page,the latency between a page fault and the time when a handler executes,the time to increase the pro-tection of a single page,the time to increase and decrease the protection over a range of 100 pages. 2) SPIN outperforms with application-specific system calls and fast in-kernel protected procedure call. DEC OSF/1 and Mach, though, communicate these events by means of more expensive traps or messages</li>
      <li>Networking: 1) Latency and Bandwidth: For DEC OSF/1, the application code executes at user level, and each packet sent involves a trap and several copy operations as the data moves across the user/kernel boundary. For SPIN, the application code executes as an extension in the kernel, where it has low-latency access to both the device and data. Each incoming packet causes a series of events to be generated for each layer in the UDP/IP protocol stack 2) Protocol forwarding:In SPIN an application installs a node into the protocol stack which redirects all data and control packets destined for a particular port number to a secondary host. The DEC OSF/1 forwarder is not able to forward protocol control packets because it executes above the transport layer. As a result it cannot maintain a protocol’s end-to-end semantics  </li>
      <li>End-to-end performance: SPIN allows a server to both control its cache and avoid the problem of double buffering. A SPIN web server implements its own hybrid caching policy based on file type. DEC OSF/1 relies on the operating system’s caching file system (no double buffering)</li>
     </ul>
   </li> 
    
   <li>Issues: 1)Scalability and the dispatcher 2)Impact of automatic storage management 3)Size of extensions</li>
   
</ul>

<h2>Exokernel: An Operating System Architecture for Application-Level Resource Management</h2>
<p>Engler, Dawson R., M. Frans Kaashoek, and James O'Toole Jr. "Exokernel: An operating system architecture for application-level resource management." ACM SIGOPS Operating Systems Review 29.5 (1995): 251-266. </p>

<ul>
  <li> The exokernel operating system architecture provides application-level management of physical resources. In the exokernel architecture, a small kernel securely exports all hardware resources through a low-level interface to untrusted library operating systems. Library operating systems use this interface to implement system objects and policies. This separation of resource protection from management allows application-specific customization of traditional operating system abstractions by extending, specializing, or even replacing libraries. </li>
  <li> We believe these problems (denies applications the advantages of domain-specific optimizations, discourages changes to the implementations of existing abstractions, restricts the flexibility of application builders) can be solved through application-level (i.e., untrusted) resource management. Exokernel, in which traditional operating system abstractions, such as virtual memory (VM) and interprocess communication (IPC), are implemented entirely at application level by untrusted software. In this architecture, <strong>a minimal kernel — which we call an exokernel — securely multiplexes available hardware resources. </strong></li>
  <li>Substantial evidence exists that applications can benefit greatly from having more control over how machine resources are used to implement higher-level abstractions</li>
  <li>the lower the level of a primitive, the more efficiently it can be implemented, and the more latitude it grants to implementors of higher-level abstractions. </li>
  <li>goal is to separate protection from management. one way to achieve it is per app per VM, another is to export hardware resources rather than emulating them.</li>
  <li>An exokernel employs three techniques to exportresources securely. First, by using secure bindings, applications can securely bind to machine resources and handle events. Second, by using visible resource revocation, applications participate in a resource revocation protocol. Third, by using an abort protocol, an exokernel can break secure bindings of uncooperative applications by force. </li>
  <li>Our solution is to allow traditional abstractions to be implemented entirely at application level.To provide the maximum opportunity for application-level re-source management, the exokernel architecture consists of a thin exokernel veneer that multiplexes and exports physical resources securely through a set of low-level primitives. Library operating systems, which use the low-level exokernel interface, implement higher-level abstractions and can define special-purpose implementations that best meet the performance and functionality goals of applications. Applications link against stan-dard libraries (e.g., WWW, POSIX, and TCP libraries for Web ap-plications) or against specialized libraries (e.g., a distributed shared memory library for parallel applications).This structure allows the extension, specialization and even replacement of abstractions.</li>
  <li>Library operating systems: since libraries are not trusted by an exokernel, they are free to trust the application. The number of kernel crossings in an exokernel system can be smaller, since most of the operating system runs in the address space of the application. Library operating systems can provide as much portability and compatibility as is desirable.An application that runs on an exokernel can freely replace these libraryoperating systems withoutany special privileges, which sim-plifies the addition and development of new standards and features.Extending or specializing a library operating system might be considerably simplifiedby modular design.To reduce the space required by these libraries, support for shared libraries and dynamic linking will be an essential part of a complete exokernel-based system. </li>
  <li>As in microkernel systems, an exokernel can provide backward compatibility in three ways: one, binary emulation of the operating system and its programs; two, by implementing its hardware ab-straction layer on top of an exokernel; and three, re-implementing the operating system’s abstractions on top of an exokernel. </li>
  <li>Design Principles: 1) Securely expose hardware: The central tenet of the exokernel architecture is that the kernel should provide secure low-level primitives that allow all hardware resources to be accessed as directly as possible. An exokernel must export privileged instructions to library operating systems to enable them to imple-ment traditional operating system abstractions such as processes and address spaces. Each exported operation can be encapsulated within a system call that checks the ownership of any resources involved.  2) Expose allocation: the library operating system should participate in every allocation decision 3) Expose Names:an exokernel should export bookkeeping data structures  4)Expose Revocation: Visible revocation allows physical names to be used easily and permits library operating systems to choose which instance of a specific resource to relinquish.  </li>
  <li>Secure Binding: a protection mechanism that decouples authorization from the actual use of a resource. We use three basic techniques to implement secure bindings: hardware mechanisms, software caching, and downloading application code. Downloading code into the kernel has two main performance advantages. The first is obvious: elimi-nation of kernelcrossings. The second is more subtle: the execution time of downloaded code can be readily bounded</li>
  <li>Revocation can either be visible or invisible to applications.</li>
  <li>The Abort Protocol: An exokernel must also be able to take resources from library operating systems that fail to respond satisfactorily to revocation requests.The actions taken when a library operating system is recalcitrant are defined by the abort protocol. To record the forced loss of a resource, we use a repossession vector. When an exokernel takes a resource from a library operating system, this fact is registered in the vector and the library operating system receives a “repossession” exception so that it can update any mappings that use the resource. For resources with state, an exokernel can write the state into another memory or disk resource. In preparation, the library operating system can pre-load the repossession vector with a list of resources that can be used for this purpose. </li>
  <li>Experimental Methodology</li>
   <ul>
      <li>Implementation of Aegis (exokernel), ExOS (library operating system), and extensions to ExOS. Compare the performance with Ultrix 4.2, a mature monolithic UNIX operating system which performs two to three times better than Mach 3.0 in a set of I/O benchmarks</li>
      <li>Hypotheses: 1) Exokernels can be very efficient. 2) Low-level, secure multiplexing of hardware resources can be implemented efficiently.  3) Traditional operating system abstractions can be implemented efficiently at application level. 4) Applications can create special-purpose implementations of these abstractions. </li>
      <li>Base Cost for null procedure and system calls. Aegis is better. Part of the reason Ultrix is less efficient  is that it performs a more expensive demultiplexing operation.</li>
      <li>Exception dispatch time: Aegis is better. part reason is that Aegis doesn't use mapped data structure</li>
      <li>Address Translation - bootstrapping & efficiency.In order to support application-level virtual memory efficiently, TLB refills must be fast. To this end, Aegis caches TLB entries (a form of secure bindings) in the kernel by overlaying the hard-ware TLB with a large software TLB (STLB) to absorb capacity misses.The STLB can be mapped using a well-known capability, which allows applicationsto efficiently probe for entries.</li>      
      <li>Protected Control transfers:Aegis provides a protectedcontrol transfer mechanismas a substrate for efficient implementations of IPC abstractions. Operationally, a protectedcontroltransfer changesthe programcounterto anagreed-upon value in the callee, donates the current time slice to the callee’s processor environment, and installs the required elements of the callee’s processor context (addressing-context identifier, address-space tag, and processor status word).</li>
      <li>Dynamic Packet Filter:The key in our approach to making filters run fast is dynamic code generation. Dynamic code generation is the creation of exe-cutable code at runtime</li>
      <li>An exokernel can be implemented efficiently.One, keeping track of owner-ship is a simple task and can therefore be implemented efficiently. Two, since the kernel provides very little functionality beyond low-level multiplexing. Three, by caching secure bind-ings in a softwareTLB, most hardware TLB misses can be handled efficiently. Four, by downloading packets filters and by employing dynamic code generation, secure binding to the network can be implemented efficiently. </li>
      <li>ExOS:The most unusual aspect of ExOS is that it manages fundamental operating system abstractions (e.g., virtual memory and process) at application level, completely within the address space of the application that is using it.This section demonstrates that basic system abstractions can be implemented at application level in a direct and efficient manner on IPC, virtual memory, and remote communication. </li>  
   </ul>
</ul>








<h2>Xen and the Art of Virtualization</h2>
<p>Barham, Paul, Boris Dragovic, Keir Fraser, Steven Hand, Tim Harris, Alex Ho, Rolf Neugebauer, Ian Pratt, and Andrew Warfield. "Xen and the art of virtualization." ACM SIGOPS operating systems review 37, no. 5 (2003): 164-177 </p>
